import pandas as pd

class Utilities:
    """
    A class to manage different utilities for each country. Can be used for different motives : utility to go to work, to study, etc.

    Parameters
    ----------
    transport_zones : gpd.GeoDataFrame
        Transport zones generated by TransportZones class.
    sinks : pd.DataFrame
        Sinks of the model.
    utility_by_country : Dict[str, float]
        Dictionary containing one utility value for each country.

    Attributes
    ----------
    sinks: pd.DataFrame
        Sinks of the model.
    utilities: pd.DataFrame
        Utilities for each transport zone.
    """

    def __init__(self, transport_zones, sinks, utility_by_country):
        
        # Assurer que country est bien string pour la jointure
        transport_zones = transport_zones.drop(columns="geometry")
        transport_zones = transport_zones[["transport_zone_id", "country"]].rename(columns={"transport_zone_id": "to"})
        
        utility_by_country_df = pd.DataFrame({
            "country": list(utility_by_country.keys()),
            "base_utility": list(utility_by_country.values())
        })
        sinks_df = sinks.reset_index()
        sinks_df["to"] = sinks_df["to"].astype(int)
        sinks_df["country"] = sinks_df["country"].astype(str)
        
        utilities_df = sinks_df.merge(transport_zones, on=["to", "country"], how="left")
        utilities_df = pd.merge(utilities_df, utility_by_country_df, on="country", how="left")


        utilities_df["utility"] = utilities_df["base_utility"]
        utilities_df = utilities_df[["to", "base_utility", "utility"]]

        self.sinks = sinks_df
        self.utilities = utilities_df

    def get(self, congestion: bool = False):
        """
        Returns a DataFrame with utility values per transport zone.
        If congestion=True, returns utility as-is.
        If congestion=False, returns base_utility as utility.
        """
        if congestion:
            return self.utilities[["to", "utility"]]
        else:
            df = self.utilities.copy()
            df["utility"] = df["base_utility"]
            return df[["to", "utility"]]

    def update(self, flows: pd.DataFrame):
        """
        Updates the utilities based on congestion level from flows.

        Parameters
        ----------
        flows : pd.DataFrame
            DataFrame with columns ['to', 'flow_volume']
        """
        # Calculer l’occupation par zone
        sink_occupation = flows.groupby("to", as_index=False)["flow_volume"].sum()
        sink_occupation = sink_occupation.rename(columns={"flow_volume": "sink_occupation"})

        # Joindre avec les sinks d'origine (contenant sink_volume)
        sink_data = self.sinks.merge(sink_occupation, on="to", how="left")
        sink_data["sink_occupation"] = sink_data["sink_occupation"].fillna(0.0)

        # Calcul du facteur d'ajustement (k_utility) — exemple non-linéaire
        sink_data["k_utility"] = 1.0 / (1.0 + 0.5 * ((sink_data["sink_occupation"] / sink_data["sink_volume"]).pow(8)))

        # Mise à jour des utilités
        updated_utilities = self.utilities.merge(sink_data[["to", "k_utility"]], on="to", how="left")
        updated_utilities["utility"] = updated_utilities["base_utility"] * updated_utilities["k_utility"]

        self.utilities = updated_utilities[["to", "base_utility", "utility"]]
